---
title: 5 minutes to Inngest
description: "Understand Inngest key concepts and benefits"
---

Your back end makes promises: when someone places an order, send an email. When payment clears, update inventory. When a user signs up, start a welcome sequence. But in the real world, things break. Networks fail. Services go down. APIs hit rate limits. Errors happen. Inngest makes sure your promises are kept, no matter what.

## Async orchestration

Modern apps do many things at once. When a user places an order, your system needs to process payment, update inventory, send emails, track analytics, and more. Making users wait for all this would be a terrible user experience. Instead, we run these tasks in the background.

The downside of async systems is that they're hard to build right. Without good tools, they turn into a mess of callbacks, lost messages, and mystery failures. It's like managing a remote team without Slack or Zoom—chaos without the right tools.


### Queue, the traditional approach

Developers commonly rely on message queues and job processors for async work. These tools work, but they're hard to use. You need to set up servers, manage queues, track state across services, and build your own retry logic. And when things eventually break, you're on your own.

### Inngest's event-driven approach

Inngest rethinks async work by managing the hard parts for you. You focus on your workflow logic. Inngest handles the infrastructure.

What Inngest does:

1. **Listens for events** from your app, webhooks, or schedules
2. **Decides which functions to run** based on your rules
3. **Makes sure functions complete** with retries and state tracking
4. **Calls your code** via HTTP when it's time to run

Why this is better:

- **No infrastructure**: No servers, queues, or workers to manage
- **Developer-friendly**: Write workflows as code, not config files
- **Built-in reliability**: Retries, state, and error handling included
- **Comprehensive debugging**: See every step, retry, and state change

## Inngest's 3 pillars

Inngest uses three main building blocks that work together to create reliable workflows.

### Events: Things that happen

Events are signals that trigger your workflows: `user.signup`, `payment.completed`. Events are the starting point for everything in Inngest.

**Originate from many places:**

- **Your app**: Send events using the Inngest SDK when important things happen
- **Webhooks**: Get events from services like Stripe, GitHub, or Shopify
- **Schedules**: Run events on a schedule, like cron jobs
- **Other functions**: Chain workflows by having functions send events

**Handy to manipulate:**

- **Filter**: Only run functions when events match certain rules
- **Batch**: Group similar events to process them together
- **Transform**: Change or add data as events flow through

Events create a single stream of activity across your whole system. Whether from your main app, microservices, webhooks, or schedules, all events flow through the same reliable pipeline.

### Functions: Your workflow logic

Functions are where your code lives. They define what happens when events occur. But Inngest functions aren't like normal functions. They're built for workflows that might take minutes, hours, or even days.

**How functions run:**

Inngest functions work differently than regular code:

- **They're durable**: Functions can pause and resume without losing their place. If your server restarts while a function waits, it picks up right where it left off.  
- **They're event-driven**: Functions start from events, wait for events, and send events. This creates systems that react to what's happening.  
- **They're distributed**: Functions don't need to run on one server. Different steps can run on different servers.  
- **Steps save progress**: When a step finishes, its result is saved forever. Retries never re-run successful steps. No duplicate charges or emails.  


**What functions can do:**

Functions support powerful patterns:

- **Make decisions**: Use if-then logic based on data or results. Create branches and loops in your workflows.  
- **Call other functions**: Build small, reusable functions. Combine them into bigger workflows.  
- **Run for days**: Perfect for approval flows, scheduled follow-ups, or monitoring. The durable design means they survive server restarts.  
- **Run in parallel**: Process many items at once. Control how many run together.  
- **Handle errors smartly**: Retry steps, compensate for failures, or alert humans when needed.  

You write code. Inngest handles the hard distributed systems problems.

### Steps: Reliable Units of work

Steps are what make Inngest special. Each step is a unit of work that can retry on its own. But steps do more than just retry—they're how you build complex workflows.

**How steps work**

Inngest runs your function step by step:

1. **First run**: Run until the first step, execute it, save the result
2. **Next runs**: Skip finished steps, run the next one
3. **On failure**: Retry only the failed step
4. **On success**: Move to the next step or finish

This gives you:

- **No wasted work**: Successful steps never run twice
- **Same data every time**: Steps see the same inputs on retries
- **Efficient runs**: Only run what needs to run
- **Clear debugging**: Know exactly what failed and why

**Step context**

Each step can access:

- The triggering event
- Results from previous steps
- Shared function state
- Your databases and APIs

Steps have the context they need to make smart decisions while keeping your code clean and maintainable.

**Types of steps**

Inngest has different step types for different needs:

<Tabs>
  <Tab title="Run" default>
    Executed in the order they're defined, with each step able to depend on the previous step's output. This enables complex workflows built with ease.  
    ![queue](/images/queue.svg)  
    Example: Sending an event from a step  
    ```ts 
      await inngest.send({
        name: "storefront/cart.checkout.completed",
        data: {...},
      });
    ```
  </Tab>
  <Tab title="Sleep">
    Pause without blocking resources. Your function stops and restarts later. Great for:
    - Waiting for other systems
    - Adding delays between retries
    - Scheduling future work
    - Rate limiting  
    ![sleep](/images/hero-dark.png)
  </Tab>
  <Tab title="Wait">
    Pause until an event arrives. Perfect for: 
    - Approval workflows
    - Coordinating systems
    - Reacting to external events 
    ![schedule](/images/checks-passed.png)
  </Tab>
  <Tab title="Schedule">
    Run at specific times or intervals for periodic tasks.  
    ![schedule](/images/checks-passed.png)
  </Tab>
  <Tab title="Parallelize">
    Run steps in parallel for efficiency and reduced total execution time.  
    ![parallelize](/images/checks-passed.png)
  </Tab>
  <Tab title="Retry">
    Automatically retry failed steps to recover from errors.  
    ![retry](/images/checks-passed.png)
  </Tab>
  <Tab title="Replay">
    Re-execute workflows from specific points for debugging and testing.  
    ![replay](/images/checks-passed.png)
  </Tab>
</Tabs>

**Combining steps**

Steps combine to create patterns:

**Parallel runs**: Run many steps at once. Control how many run together.  
**Conditional steps**: Skip or run steps based on data. Build dynamic workflows.  
**Loops**: Process lists of data in parallel or sequence.  
**Rollbacks**: Define undo steps that run when later steps fail.  

Steps transform Inngest from a job queue into a workflow engine. By breaking work into retryable units, you get reliability without complexity.

## It's all about great DX

### Comprehensive tooling

SDKs, REST API, and dashboard

### Workflow management 

**Flow control**

* concurrency  
* throttling  
* rate limiting
* priority

Inngest includes tools to manage workflows in production. These features replace custom tools with built-in capabilities.

**Working with environments**  

Inngest supports multiple environments. Each environment is separate, with its own events, functions, and history.  
**Dev and staging** environments let you test safely. Replay production events in staging to debug issues. Move tested workflows from dev to staging to production.  
**Branch environments** spin up for each pull request. Test workflow changes in isolation. Check event changes. Get team feedback before merging.  

**Function replay: Debug with time travel**

Function replay is a powerful debugging tool. When something breaks in production, replay any past function run with the same data and context.  
Replay helps you:
- Debug production issues safely
- Test fixes with real data that caused failures
- Check changes by replaying sample runs
- Review past runs for audits

During replay, functions run in a sandbox. Change code, adjust logic, or add logging without affecting production. Once fixed, deploy knowing it handles the failing cases.

**Control running workflows**

Production workflows need runtime control. Inngest lets you:  
**Pause functions** to stop new runs while current work finishes. Use this for:
- Maintenance windows
- Investigating issues without making more failures
- Controlling processing speed

**Bulk operations** to manage many runs at once:
- Cancel runs matching certain rules
- Retry failed runs after fixing dependencies
- Pause runs for specific users during problems

Use the dashboard for quick actions or the API for automation. Build runbooks that pause functions during known maintenance times.

### Monitoring and observability

Seeing what's happening in async workflows is crucial. Inngest provides tools to understand every part of your system.

**Real-time monitoring**

The Inngest dashboard shows your system live:  
**Function metrics** show run counts, success rates, and speed. Spot problems instantly. Filter by function, time, or status to dig deeper.  
**Event flow** shows how events move through your system. See what each event triggers. Find bottlenecks. Understand dependencies.  
**Live view** lets you watch functions run. See each step complete. Find slowdowns or failures as they happen.  

**Detailed insights**

Every function run is tracked:  
**Full logs** capture inputs, outputs, and timing for every step. Everything is in one place, not scattered across services.  
**Error details** with stack traces and context. See why something failed, what the inputs were, and what worked before failing.  
**Performance data** shows time in each step, wait times, and retry delays. Find and fix slow steps.  

**Metrics and alerts**

Inngest provides metrics for monitoring:

**System health**:
- Event processing speed and backlog
- Function run rates
- Queue sizes and delays
- Error rates by function and step

**Business metrics**:
- Custom metrics from your functions
- Event counts by type
- Workflow completion rates
- SLA tracking for time-sensitive work

Connect these to your monitoring tools via webhooks, APIs, or export to Datadog, New Relic, or CloudWatch. Set alerts for errors, slowdowns, or business problems.

**Debugging tools**

When problems happen, Inngest helps you investigate:  
**Event inspection** shows the full event data and what it triggered. Trace events through your system.  
**Step debugging** lets you see the state at each step. Understand what data was available and what happened.  
**Time travel** via replay lets you re-run past executions with more logging to understand problems.  

With monitoring, observability, and debugging combined, you always know what's happening in your workflows.


## Recap: Inngest vs the rest
Inngest provides a modern alternative to traditional message queues like Kafka or RabbitMQ, focusing on event-driven orchestration with built-in reliability and state management. Here's how Inngest compares to conventional message queues:

| Feature            | Message Queues                | Inngest                                         |
|--------------------|-------------------------------------------------|-------------------------------------------------|
| Event-driven       | <Icon icon="check" iconType="solid" /> Yes      | <Icon icon="check" iconType="solid" /> Yes      |
| Durable execution  | <Icon icon="check" iconType="solid" /> Yes      | <Icon icon="check" iconType="solid" /> Yes      |
| State management   | <Icon icon="xmark" iconType="solid" color="red" /> No | <Icon icon="check" iconType="solid" /> Yes      |
| Built-in retries   | <Icon icon="check" iconType="solid" /> Basic    | <Icon icon="check" iconType="solid" /> Advanced |
| Delivery guarantee | <Icon icon="triangle-exclamation" iconType="solid" color="orange" /> Varies | <Icon icon="check" iconType="solid" /> Yes      |
| Flow control       | <Icon icon="xmark" iconType="solid" color="red" /> Manual | <Icon icon="check" iconType="solid" /> Built-in |
| Monitoring         | <Icon icon="triangle-exclamation" iconType="solid" color="orange" /> External | <Icon icon="check" iconType="solid" /> Built-in |
| Developer Experience | <Icon icon="triangle-exclamation" iconType="solid" color="orange" /> Moderate | <Icon icon="check" iconType="solid" /> Excellent |
| Complexity        | <Icon icon="xmark" iconType="solid" color="red" /> High | <Icon icon="check" iconType="solid" /> Low      |
| Infrastructure   | <Icon icon="xmark" iconType="solid" color="red" /> Requires setup | <Icon icon="check" iconType="solid"/> Zero setup |



## It's time to build

Ready to build better async workflows? Install the SDK for your language, create your first function, and explore our examples and best practices.

- **Interactive tutorial**: Build a complete order processing workflow
- **Architecture guide**: Learn how Inngest works under the hood
- **Migration guide**: Move existing queue workflows to Inngest
- **API reference**: Complete documentation of all features

Inngest changes how we build async, event-driven apps. Start building more reliable workflows today—your future self will thank you.